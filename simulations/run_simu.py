"""
This script runs simulations with different VSL control modes on generated real-world data simulation days.
"""

import traci
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import xml.etree.ElementTree as ET
import sumolib

def run_simu():
    ROOT = f"match-sims/{DAY}/"
    SUMO_CONFIG = f"{ROOT}osm.sumocfg"
    NET = f"{ROOT}osm.net.xml.gz"
    PREDICTIONS_ROOT = "../model/predictions/"

    EDGE_PREDICTION_MAP = {
        "949385199-AddedOffRampEdge": f"{PREDICTIONS_ROOT}predictions_{DAY}_{DAY_PLUS1}_drakewell__1163_avgspeed_nw.csv",
        "28040025": f"{PREDICTIONS_ROOT}predictions_{DAY}_{DAY_PLUS1}_drakewell__1163_avgspeed_se.csv",
        "929125464": f"{PREDICTIONS_ROOT}predictions_{DAY}_{DAY_PLUS1}_drakewell__1418_avgspeed_e.csv",
        "-28039501#0": f"{PREDICTIONS_ROOT}predictions_{DAY}_{DAY_PLUS1}_drakewell__1418_avgspeed_w.csv",
    }

    SENSOR_EDGES = list(EDGE_PREDICTION_MAP.keys())

    DEFAULT_SPEED_LIMIT = 30 * 0.44704
    SPEED_THRESHOLD = 30 * 0.44704
    SPEED_REDUCTION_1 = 25 * 0.44704
    SPEED_REDUCTION_2 = 20 * 0.44704

    UPDATE_INTERVAL = 1800
    SIM_DURATION = 86400
    HIGH_TRAFFIC_THRESHOLD = 50

    # Load the predictions for each edge
    edge_pred_dicts = {}
    for edge, filename in EDGE_PREDICTION_MAP.items():
        df = pd.read_csv(filename, parse_dates=["timestamp"])
        sim_start_time = df["timestamp"].min()
        pred_dict = {}
        for _, row in df.iterrows():
            sim_time = (row["timestamp"] - sim_start_time).total_seconds()
            sim_time_rounded = int(round(sim_time / UPDATE_INTERVAL) * UPDATE_INTERVAL)
            pred_dict[sim_time_rounded] = row["predicted_speed"] * 0.44704
        edge_pred_dicts[edge] = pred_dict
        print(f"Loaded predictions for sensor edge {edge} with {len(pred_dict)} intervals.")

    # Get the data that we need from the tripinfo files generated by the simulation as these are not available in real-time.
    def parse_tripinfo_full(file_name):
        try:
            tree = ET.parse(file_name)
            root = tree.getroot()
        except Exception as e:
            print(f"Error reading tripinfo file {file_name}: {e}")
            return {}
        total_duration = 0.0
        total_routeLength = 0.0
        total_speed = 0.0
        total_waitingTime = 0.0
        total_timeLoss = 0.0
        total_departDelay = 0.0
        count = 0
        for trip in root.findall("tripinfo"):
            try:
                d = float(trip.attrib.get("duration", 0))
                rl = float(trip.attrib.get("routeLength", 0))
                speed = rl / d if d > 0 else 0
                wt = float(trip.attrib.get("waitingTime", 0))
                tl = float(trip.attrib.get("timeLoss", 0))
                dd = float(trip.attrib.get("departDelay", 0))
            except:
                continue
            total_duration += d
            total_routeLength += rl
            total_speed += speed
            total_waitingTime += wt
            total_timeLoss += tl
            total_departDelay += dd
            count += 1
        if count == 0:
            return {}
        return {
            "avg_duration": total_duration / count,
            "avg_routeLength": total_routeLength / count,
            "avg_speed": total_speed / count,
            "avg_waitingTime": total_waitingTime / count,
            "avg_timeLoss": total_timeLoss / count,
            "avg_departDelay": total_departDelay / count
        }

    # Get real-time metrics for an edge from TRACI
    def get_edge_metrics(net, edge_id, actual_speed):
        try:
            edge = net.getEdge(edge_id)
        except Exception as e:
            print(f"Error retrieving edge {edge_id}: {e}")
            return None, None, None
        waiting_time = sum(traci.lane.getWaitingTime(lane.getID()) for lane in edge.getLanes())
        veh_count = traci.edge.getLastStepVehicleNumber(edge_id)
        length = edge.getLength()
        travel_duration = length / actual_speed if actual_speed > 0 else None
        return waiting_time, veh_count, travel_duration

    # SIMULATION
    def run_simulation(control_mode, edge_pred_dicts, net):
        tripinfo_file = f"{ROOT}tripinfo_{control_mode}.xml"
        traci.start(["sumo", "-c", SUMO_CONFIG, "--tripinfo-output", tripinfo_file])
        traci.simulation.setScale("1.0")

        metrics = []
        current_step = 0
        last_update = -UPDATE_INTERVAL
        congestion_list = []
        edge_time_list = []
        global_emission_list = []

        while current_step < SIM_DURATION:
            traci.simulationStep()

            if current_step - last_update >= UPDATE_INTERVAL:
                applied_vsl_list = []
                actual_speed_list = []
                waiting_time_list = []
                veh_count_list = []
                travel_duration_list = []
                edge_time_per_update = []

                # Apply VSL strategy to each edge for which we have data
                for edge in SENSOR_EDGES:
                    if control_mode == "baseline":
                        vsl = DEFAULT_SPEED_LIMIT
                        traci.edge.setMaxSpeed(edge, vsl)
                        pred_val = None
                    elif control_mode == "lower_limit":
                        vsl = SPEED_REDUCTION_2 # lowest speed limit to prove reduction does not come solely from lower speed limit
                        traci.edge.setMaxSpeed(edge, vsl)
                        pred_val = None
                    elif control_mode == "reactive_rule":
                        cur_meas = traci.edge.getLastStepMeanSpeed(edge)
                        traffic_density = traci.edge.getLastStepVehicleNumber(edge)

                        if traffic_density > HIGH_TRAFFIC_THRESHOLD:
                            vsl = SPEED_REDUCTION_2  # Heavy congestion
                        elif cur_meas < SPEED_REDUCTION_1:
                            vsl = SPEED_REDUCTION_1  # Moderate congestion
                        else:
                            vsl = DEFAULT_SPEED_LIMIT  # Normal conditions

                        traci.edge.setMaxSpeed(edge, vsl)
                        pred_val = None
                    elif control_mode == "predictive":
                        future_time = current_step
                        key = int(round(future_time / UPDATE_INTERVAL) * UPDATE_INTERVAL)
                        pred_speed = edge_pred_dicts[edge].get(key, DEFAULT_SPEED_LIMIT)
                        vsl = pred_speed if pred_speed < SPEED_THRESHOLD else DEFAULT_SPEED_LIMIT
                        traci.edge.setMaxSpeed(edge, vsl)
                        pred_val = pred_speed
                    elif control_mode == "predictive_round2":
                        future_time = current_step
                        key = int(round(future_time / UPDATE_INTERVAL) * UPDATE_INTERVAL)
                        pred_speed = edge_pred_dicts[edge].get(key, DEFAULT_SPEED_LIMIT)
                        pred_speed = (2 * round(pred_speed/2))
                        vsl = pred_speed if pred_speed < SPEED_THRESHOLD else DEFAULT_SPEED_LIMIT
                        traci.edge.setMaxSpeed(edge, vsl)
                        pred_val = pred_speed
                    elif control_mode == "predictive_round5":
                        future_time = current_step
                        key = int(round(future_time / UPDATE_INTERVAL) * UPDATE_INTERVAL)
                        pred_speed = edge_pred_dicts[edge].get(key, DEFAULT_SPEED_LIMIT)
                        pred_speed = (5 * round(pred_speed/5))
                        vsl = pred_speed if pred_speed < SPEED_THRESHOLD else DEFAULT_SPEED_LIMIT
                        traci.edge.setMaxSpeed(edge, vsl)
                        pred_val = pred_speed
                    elif control_mode == "predictive_30":
                        future_time = current_step + 1800
                        key = int(round(future_time / UPDATE_INTERVAL) * UPDATE_INTERVAL)
                        pred_speed = edge_pred_dicts[edge].get(key, DEFAULT_SPEED_LIMIT)
                        vsl = pred_speed if pred_speed < SPEED_THRESHOLD else DEFAULT_SPEED_LIMIT
                        traci.edge.setMaxSpeed(edge, vsl)
                        pred_val = pred_speed
                    else:
                        vsl = DEFAULT_SPEED_LIMIT
                        pred_val = None

                    applied_vsl_list.append(vsl)
                    act_speed = traci.edge.getLastStepMeanSpeed(edge)
                    actual_speed_list.append(act_speed)
                    wt, veh, td = get_edge_metrics(net, edge, act_speed)
                    waiting_time_list.append(wt)
                    veh_count_list.append(veh)
                    travel_duration_list.append(td)
                    if veh and veh > 0 and td is not None:
                        edge_time = td + (wt / veh)
                    else:
                        edge_time = td if td is not None else 0
                    edge_time_per_update.append(edge_time)

                # Average metrics over all sensor edges
                avg_applied_vsl = sum(applied_vsl_list) / len(applied_vsl_list)
                avg_actual_speed = sum(actual_speed_list) / len(actual_speed_list)
                avg_waiting = sum(waiting_time_list) / len(waiting_time_list)
                avg_veh = sum(veh_count_list) / len(veh_count_list)
                filtered_td = [x for x in travel_duration_list if x is not None]
                avg_td = sum(filtered_td) / len(filtered_td) if filtered_td else 0
                avg_edge_time = sum(edge_time_per_update) / len(edge_time_per_update)
                congestion_metric = avg_waiting / (avg_veh + 1)  if avg_veh is not None else None
                if congestion_metric is not None:
                    congestion_list.append(congestion_metric)
                edge_time_list.append(avg_edge_time)
                # For logging, use the first sensor edge's prediction as representative.
                rep_pred = pred_val

                emission_values = []
                for edge in SENSOR_EDGES:
                    try:
                        edge_obj = net.getEdge(edge)
                        edge_emission = sum(traci.lane.getCO2Emission(lane.getID()) for lane in edge_obj.getLanes())
                    except Exception:
                        edge_emission = 0
                    emission_values.append(edge_emission)
                avg_emission = sum(emission_values) / len(emission_values)
                global_emission_list.append(avg_emission)

                metrics.append({
                    "sim_time": current_step,
                    "control_mode": control_mode,
                    "applied_vsl": avg_applied_vsl,
                    "actual_speed": avg_actual_speed,
                    "waiting_time": avg_waiting,
                    "vehicle_count": avg_veh,
                    "travel_duration": avg_td,
                    "avg_edge_time": avg_edge_time,
                    "predicted_speed": rep_pred,
                    "congestion_metric": congestion_metric,
                    "avg_emission": avg_emission
                })
                print(f"Step {current_step}: Mode={control_mode}, Applied VSL={avg_applied_vsl:.2f}, Actual Speed={avg_actual_speed:.2f}, Waiting={avg_waiting:.2f}, Count={avg_veh:.2f}, Travel Duration={'{:.2f}'.format(avg_td) if avg_td else 'N/A'}, Avg Edge Time={'{:.2f}'.format(avg_edge_time) if avg_edge_time else 'N/A'}, Predicted={rep_pred if rep_pred is not None else 'N/A'}")
                last_update = current_step
            current_step += 1
        traci.close()
        tripinfo_stats = parse_tripinfo_full(tripinfo_file)
        avg_congestion = sum(congestion_list) / len(congestion_list) if congestion_list else None
        avg_edge_time_overall = sum(edge_time_list) / len(edge_time_list) if edge_time_list else None
        avg_emission_overall = sum(global_emission_list) / len(global_emission_list) if global_emission_list else None
        return metrics, tripinfo_stats, avg_congestion, avg_edge_time_overall, avg_emission_overall

    # Run simulations for all control modes we need to compare
    control_modes = ["baseline", "lower_limit", "reactive_rule", "predictive", "predictive_round2", "predictive_round5", "predictive_30"]
    all_metrics = []
    agg_metrics = []
    net = sumolib.net.readNet(NET)
    for mode in control_modes:
        print(f"Running simulation for control mode: {mode}")
        mode_metrics, tripinfo_stats, avg_congestion, avg_edge_time, avg_emission = run_simulation(mode, edge_pred_dicts,
                                                                                                   net)
        all_metrics.extend(mode_metrics)
        agg_dict = {"control_mode": mode, "avg_congestion": avg_congestion, "avg_edge_time": avg_edge_time, "avg_emission": avg_emission}
        if tripinfo_stats:
            agg_dict.update(tripinfo_stats)
        agg_metrics.append(agg_dict)

    # Save full simulation metrics
    df_metrics = pd.DataFrame(all_metrics)
    df_metrics["applied_vsl"] = df_metrics["applied_vsl"] * 2.23694
    df_metrics["actual_speed"] = df_metrics["actual_speed"] * 2.23694
    df_metrics["predicted_speed"] = df_metrics["predicted_speed"].apply(lambda x: x * 2.23694 if x is not None else x)
    df_metrics.to_csv(f"{ROOT}simulation_metrics.csv", index=False)
    print("Saved simulation metrics to simulation_metrics.csv")

    # Save aggregated metrics
    df_agg = pd.DataFrame(agg_metrics)
    df_agg["avg_speed"] = df_agg["avg_speed"] * 2.23694
    df_agg.to_csv(f"{ROOT}aggregated_metrics.csv", index=False)
    print("Saved aggregated metrics to aggregated_metrics.csv")


    # Plots
    sns.set(style="whitegrid")
    plt.figure(figsize=(12, 6))
    sns.lineplot(data=df_metrics, x=df_metrics["sim_time"] / 60.0, y="applied_vsl", hue="control_mode", marker="o")
    plt.xlabel("Time (minutes)")
    plt.ylabel("Applied VSL (m/s)")
    plt.title("Applied VSL Over Time - Averaged over All Sensor Edges")
    plt.tight_layout()
    plt.savefig(f"{ROOT}applied_vsl_over_time.png")
    plt.show()

    metrics_to_plot = {
        "avg_duration": "Average Trip Duration (s)",
        "avg_emission": "Average CO2 Emission (g)"
    }
    for metric, label in metrics_to_plot.items():
        if metric in df_agg.columns:
            plt.figure(figsize=(12, 6))
            ax = sns.barplot(data=df_agg, x="control_mode", y=metric)
            plt.xlabel("Control Mode")
            plt.ylabel(label)
            plt.title(label + " by Control Mode")
            ax.set_ylim(0, df_agg[metric].max() * 1.2)
            plt.tight_layout()
            plt.savefig(ROOT + metric + ".png")
            plt.show()

    # Compute baseline values and percentage changes
    baseline_duration = df_agg.loc[df_agg["control_mode"]=="baseline", "avg_duration"].iloc[0]
    baseline_emission = df_agg.loc[df_agg["control_mode"]=="baseline", "avg_emission"].iloc[0]

    df_agg["perc_change_duration"] = ((df_agg["avg_duration"] - baseline_duration) / baseline_duration) * 100
    df_agg["perc_change_emission"] = ((df_agg["avg_emission"] - baseline_emission) / baseline_emission) * 100

    plt.figure(figsize=(12,6))
    sns.barplot(data=df_agg, x="control_mode", y="perc_change_duration")
    plt.xlabel("Control Mode")
    plt.ylabel("Percentage Change in Trip Duration (%)")
    plt.title("Percentage Change in Average Trip Duration Relative to Baseline")
    plt.tight_layout()
    plt.savefig(f"{ROOT}perc_change_duration.png")
    plt.show()

    plt.figure(figsize=(12,6))
    sns.barplot(data=df_agg, x="control_mode", y="perc_change_emission")
    plt.xlabel("Control Mode")
    plt.ylabel("Percentage Change in CO2 Emission (%)")
    plt.title("Percentage Change in Average CO2 Emission Relative to Baseline")
    plt.tight_layout()
    plt.savefig(f"{ROOT}perc_change_emission.png")
    plt.show()


# Run the required pre-prepared simulations
DAY = "2024-03-06"
DAY_PLUS1 = "2024-03-07"
run_simu()

DAY = "2024-04-03"
DAY_PLUS1 = "2024-04-04"
run_simu()

DAY = "2024-05-04"
DAY_PLUS1 = "2024-05-05"
run_simu()

DAY = "2024-08-24"
DAY_PLUS1 = "2024-08-25"
run_simu()

DAY = "2024-09-18"
DAY_PLUS1 = "2024-09-19"
run_simu()

DAY = "2024-03-31"
DAY_PLUS1 = "2024-04-01"
run_simu()

DAY = "2024-05-19"
DAY_PLUS1 = "2024-05-20"
run_simu()

DAY = "2024-09-14"
DAY_PLUS1 = "2024-09-15"
run_simu()

DAY = "2024-10-05"
DAY_PLUS1 = "2024-10-06"
run_simu()


