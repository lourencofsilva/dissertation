"""
This script is identical to run_simu.py but with the objective of running simulations for the rule-based reactive
benchmark to find the optimal speed reduction values for the reactive rule.
"""

import time
import traci
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import xml.etree.ElementTree as ET
import sumolib

def run_simu():
    ROOT = f"example-root/{DAY}/"
    SUMO_CONFIG = f"{ROOT}osm.sumocfg"
    NET = f"{ROOT}osm.net.xml.gz"
    PREDICTIONS_ROOT = "../model/predictions/"

    EDGE_PREDICTION_MAP = {
        "949385199-AddedOffRampEdge": f"{PREDICTIONS_ROOT}predictions_{DAY}_{DAY_PLUS1}_drakewell__1163_avgspeed_nw.csv",
        "28040025": f"{PREDICTIONS_ROOT}predictions_{DAY}_{DAY_PLUS1}_drakewell__1163_avgspeed_se.csv",
        "929125464": f"{PREDICTIONS_ROOT}predictions_{DAY}_{DAY_PLUS1}_drakewell__1418_avgspeed_e.csv",
        "-28039501#0": f"{PREDICTIONS_ROOT}predictions_{DAY}_{DAY_PLUS1}_drakewell__1418_avgspeed_w.csv",
    }

    SENSOR_EDGES = list(EDGE_PREDICTION_MAP.keys())

    DEFAULT_SPEED_LIMIT = 30 * 0.44704
    SPEED_REDUCTION = [x * 0.44704 for x in [10, 15, 20, 25]]
    HIGH_TRAFFIC_THRESHOLD = [30, 40, 50]

    UPDATE_INTERVAL = 1800
    SIM_DURATION = 86400

    # Load the predictions for each edge
    edge_pred_dicts = {}
    for edge, filename in EDGE_PREDICTION_MAP.items():
        df = pd.read_csv(filename, parse_dates=["timestamp"])
        sim_start_time = df["timestamp"].min()
        pred_dict = {}
        for _, row in df.iterrows():
            sim_time = (row["timestamp"] - sim_start_time).total_seconds()
            sim_time_rounded = int(round(sim_time / UPDATE_INTERVAL) * UPDATE_INTERVAL)
            pred_dict[sim_time_rounded] = row["predicted_speed"] * 0.44704
        edge_pred_dicts[edge] = pred_dict
        print(f"Loaded predictions for sensor edge {edge} with {len(pred_dict)} intervals.")

    # Get the data that we need from the tripinfo files generated by the simulation as these are not available in real-time.
    def parse_tripinfo_full(file_name):
        try:
            tree = ET.parse(file_name)
            root = tree.getroot()
        except Exception as e:
            print(f"Error reading tripinfo file {file_name}: {e}")
            return {}
        total_duration = 0.0
        total_routeLength = 0.0
        total_speed = 0.0
        total_waitingTime = 0.0
        total_timeLoss = 0.0
        total_departDelay = 0.0
        count = 0
        for trip in root.findall("tripinfo"):
            try:
                d = float(trip.attrib.get("duration", 0))
                rl = float(trip.attrib.get("routeLength", 0))
                speed = rl / d if d > 0 else 0
                wt = float(trip.attrib.get("waitingTime", 0))
                tl = float(trip.attrib.get("timeLoss", 0))
                dd = float(trip.attrib.get("departDelay", 0))
            except:
                continue
            total_duration += d
            total_routeLength += rl
            total_speed += speed
            total_waitingTime += wt
            total_timeLoss += tl
            total_departDelay += dd
            count += 1
        if count == 0:
            return {}
        return {
            "avg_duration": total_duration / count,
            "avg_routeLength": total_routeLength / count,
            "avg_speed": total_speed / count,
            "avg_waitingTime": total_waitingTime / count,
            "avg_timeLoss": total_timeLoss / count,
            "avg_departDelay": total_departDelay / count
        }

    # Get real-time metrics for an edge from TRACI
    def get_edge_metrics(net, edge_id, actual_speed):
        try:
            edge = net.getEdge(edge_id)
        except Exception as e:
            print(f"Error retrieving edge {edge_id}: {e}")
            return None, None, None
        waiting_time = sum(traci.lane.getWaitingTime(lane.getID()) for lane in edge.getLanes())
        veh_count = traci.edge.getLastStepVehicleNumber(edge_id)
        length = edge.getLength()
        travel_duration = length / actual_speed if actual_speed > 0 else None
        return waiting_time, veh_count, travel_duration

    # SIMULATION
    def run_simulation(control_mode, edge_pred_dicts, net, reduction_index_l=0, reduction_index_h=1, threshold_index=0):
        tripinfo_file = f"{ROOT}tripinfo_{control_mode}.xml"
        traci.start(["sumo", "-c", SUMO_CONFIG, "--tripinfo-output", tripinfo_file])
        traci.simulation.setScale("1.0")

        metrics = []
        current_step = 0
        last_update = -UPDATE_INTERVAL
        congestion_list = []
        edge_time_list = []
        global_emission_list = []
        step_start = time.time()

        while current_step < SIM_DURATION:
            traci.simulationStep()

            if current_step - last_update >= UPDATE_INTERVAL:
                step_duration = time.time() - step_start
                # Check if the simulation step took too long
                if step_duration > 2:
                    print(
                        f"Step {current_step}: Simulation step took {step_duration:.2f} seconds, exceeding 2 seconds. Aborting simulation.")
                    traci.close()
                    # Return extremely high values to indicate simulation failure
                    return None, None, None, None, None
                step_start = time.time()

                applied_vsl_list = []
                actual_speed_list = []
                waiting_time_list = []
                veh_count_list = []
                travel_duration_list = []
                edge_time_per_update = []

                # Apply VSL strategy to each edge for which we have data
                for edge in SENSOR_EDGES:
                    if control_mode == "baseline":
                        vsl = DEFAULT_SPEED_LIMIT
                        traci.edge.setMaxSpeed(edge, vsl)
                        pred_val = None
                    elif control_mode == "lower_limit":
                        vsl = SPEED_REDUCTION[
                            0]  # lowest speed limit to prove reduction does not come solely from lower speed limit
                        traci.edge.setMaxSpeed(edge, vsl)
                        pred_val = None
                    elif control_mode == "reactive_rule":
                        cur_meas = traci.edge.getLastStepMeanSpeed(edge)
                        traffic_density = traci.edge.getLastStepVehicleNumber(edge)

                        if traffic_density > HIGH_TRAFFIC_THRESHOLD[threshold_index]:
                            vsl = SPEED_REDUCTION[reduction_index_l]  # Heavy congestion
                        elif cur_meas < SPEED_REDUCTION[reduction_index_h]:
                            vsl = SPEED_REDUCTION[reduction_index_h]  # Moderate congestion
                        else:
                            vsl = DEFAULT_SPEED_LIMIT  # Normal conditions

                        traci.edge.setMaxSpeed(edge, vsl)
                        pred_val = None
                    else:
                        vsl = DEFAULT_SPEED_LIMIT
                        pred_val = None

                    applied_vsl_list.append(vsl)
                    act_speed = traci.edge.getLastStepMeanSpeed(edge)
                    actual_speed_list.append(act_speed)
                    wt, veh, td = get_edge_metrics(net, edge, act_speed)
                    waiting_time_list.append(wt)
                    veh_count_list.append(veh)
                    travel_duration_list.append(td)
                    if veh and veh > 0 and td is not None:
                        edge_time = td + (wt / veh)
                    else:
                        edge_time = td if td is not None else 0
                    edge_time_per_update.append(edge_time)

                # Average metrics over all sensor edges
                avg_applied_vsl = sum(applied_vsl_list) / len(applied_vsl_list)
                avg_actual_speed = sum(actual_speed_list) / len(actual_speed_list)
                avg_waiting = sum(waiting_time_list) / len(waiting_time_list)
                avg_veh = sum(veh_count_list) / len(veh_count_list)
                filtered_td = [x for x in travel_duration_list if x is not None]
                avg_td = sum(filtered_td) / len(filtered_td) if filtered_td else 0
                avg_edge_time = sum(edge_time_per_update) / len(edge_time_per_update)
                congestion_metric = avg_waiting / (avg_veh + 1) if avg_veh is not None else None
                if congestion_metric is not None:
                    congestion_list.append(congestion_metric)
                edge_time_list.append(avg_edge_time)
                # For logging, use the first sensor edge's prediction as representative.
                rep_pred = pred_val

                emission_values = []
                for edge in SENSOR_EDGES:
                    try:
                        edge_obj = net.getEdge(edge)
                        edge_emission = sum(traci.lane.getCO2Emission(lane.getID()) for lane in edge_obj.getLanes())
                    except Exception:
                        edge_emission = 0
                    emission_values.append(edge_emission)
                avg_emission = sum(emission_values) / len(emission_values)
                global_emission_list.append(avg_emission)

                metrics.append({
                    "sim_time": current_step,
                    "control_mode": control_mode,
                    "applied_vsl": avg_applied_vsl,
                    "actual_speed": avg_actual_speed,
                    "waiting_time": avg_waiting,
                    "vehicle_count": avg_veh,
                    "travel_duration": avg_td,
                    "avg_edge_time": avg_edge_time,
                    "predicted_speed": rep_pred,
                    "congestion_metric": congestion_metric,
                    "avg_emission": avg_emission
                })
                print(
                    f"Step {current_step}: Duration={step_duration:.2f}, Mode={control_mode}, Applied VSL={avg_applied_vsl:.2f}, Actual Speed={avg_actual_speed:.2f}, Waiting={avg_waiting:.2f}, Count={avg_veh:.2f}, Travel Duration={'{:.2f}'.format(avg_td) if avg_td else 'N/A'}, Avg Edge Time={'{:.2f}'.format(avg_edge_time) if avg_edge_time else 'N/A'}, Predicted={rep_pred if rep_pred is not None else 'N/A'}")
                last_update = current_step

            current_step += 1

        traci.close()
        tripinfo_stats = parse_tripinfo_full(tripinfo_file)
        avg_congestion = sum(congestion_list) / len(congestion_list) if congestion_list else None
        avg_edge_time_overall = sum(edge_time_list) / len(edge_time_list) if edge_time_list else None
        avg_emission_overall = sum(global_emission_list) / len(global_emission_list) if global_emission_list else None
        return metrics, tripinfo_stats, avg_congestion, avg_edge_time_overall, avg_emission_overall

    # Run simulations for all control modes we need to compare
    control_modes = ["baseline", "reactive_rule"]
    all_metrics = []
    agg_metrics = []
    net = sumolib.net.readNet(NET)
    for mode in control_modes:
        if mode == "reactive_rule":
            for reduction_index_l in range(len(SPEED_REDUCTION) - 1):
                for reduction_index_h in range(reduction_index_l + 1, len(SPEED_REDUCTION)):
                    for threshold_index in range(len(HIGH_TRAFFIC_THRESHOLD)):
                        print(f"Running simulation for control mode: {mode} with reduction index low {reduction_index_l}, reduction index high {reduction_index_h} and threshold index {threshold_index}")
                        mode_metrics, tripinfo_stats, avg_congestion, avg_edge_time, avg_emission = run_simulation(mode, edge_pred_dicts, net, reduction_index_l, reduction_index_h, threshold_index)
                        if not mode_metrics:
                            continue
                        all_metrics.extend(mode_metrics)
                        agg_dict = {"control_mode": f"{mode}_ril_{reduction_index_l}_rih_{reduction_index_h}_ti_{threshold_index}", "avg_congestion": avg_congestion, "avg_edge_time": avg_edge_time, "avg_emission": avg_emission}
                        if tripinfo_stats:
                            agg_dict.update(tripinfo_stats)
                        agg_metrics.append(agg_dict)
        else:
            print(f"Running simulation for control mode: {mode}")
            mode_metrics, tripinfo_stats, avg_congestion, avg_edge_time, avg_emission = run_simulation(mode, edge_pred_dicts,
                                                                                                       net)
            all_metrics.extend(mode_metrics)
            agg_dict = {"control_mode": mode, "avg_congestion": avg_congestion, "avg_edge_time": avg_edge_time, "avg_emission": avg_emission}
            if tripinfo_stats:
                agg_dict.update(tripinfo_stats)
            agg_metrics.append(agg_dict)

    # Save full simulation metrics
    df_metrics = pd.DataFrame(all_metrics)
    df_metrics["applied_vsl"] = df_metrics["applied_vsl"] * 2.23694
    df_metrics["actual_speed"] = df_metrics["actual_speed"] * 2.23694
    df_metrics["predicted_speed"] = df_metrics["predicted_speed"].apply(lambda x: x * 2.23694 if x is not None else x)
    df_metrics.to_csv(f"{ROOT}simulation_metrics.csv", index=False)
    print("Saved simulation metrics to simulation_metrics.csv")

    # Save aggregated metrics
    df_agg = pd.DataFrame(agg_metrics)
    df_agg["avg_speed"] = df_agg["avg_speed"] * 2.23694
    df_agg.to_csv(f"{ROOT}aggregated_metrics.csv", index=False)
    print("Saved aggregated metrics to aggregated_metrics.csv")


    # Plots
    sns.set(style="whitegrid")
    plt.figure(figsize=(12, 6))
    sns.lineplot(data=df_metrics, x=df_metrics["sim_time"] / 60.0, y="applied_vsl", hue="control_mode", marker="o")
    plt.xlabel("Time (minutes)")
    plt.ylabel("Applied VSL (m/s)")
    plt.title("Applied VSL Over Time")
    plt.tight_layout()
    plt.savefig(f"{ROOT}applied_vsl_over_time.png")
    plt.show()

    metrics_to_plot = {
        "avg_duration": "Average Trip Duration (s)",
        "avg_emission": "Average CO2 Emission (g)"
    }
    for metric, label in metrics_to_plot.items():
        if metric in df_agg.columns:
            plt.figure(figsize=(12, 6))
            ax = sns.barplot(data=df_agg, x="control_mode", y=metric)
            plt.xticks(rotation=45)
            plt.xlabel("Control Mode")
            plt.ylabel(label)
            plt.title(label + " by Control Mode")
            ax.set_ylim(0, df_agg[metric].max() * 1.2)
            plt.tight_layout()
            plt.savefig(ROOT + metric + ".png")
            plt.show()

    # Compute baseline values and percentage changes
    baseline_duration = df_agg.loc[df_agg["control_mode"]=="baseline", "avg_duration"].iloc[0]
    baseline_emission = df_agg.loc[df_agg["control_mode"]=="baseline", "avg_emission"].iloc[0]

    df_agg["perc_change_duration"] = ((df_agg["avg_duration"] - baseline_duration) / baseline_duration) * 100
    df_agg["perc_change_emission"] = ((df_agg["avg_emission"] - baseline_emission) / baseline_emission) * 100

    plt.figure(figsize=(12,6))
    sns.barplot(data=df_agg, x="control_mode", y="perc_change_duration")
    plt.xticks(rotation=45)
    plt.xlabel("Control Mode")
    plt.ylabel("Percentage Change in Trip Duration (%)")
    plt.title("Percentage Change in Average Trip Duration Relative to Baseline")
    plt.tight_layout()
    plt.savefig(f"{ROOT}perc_change_duration.png")
    plt.show()

    plt.figure(figsize=(12,6))
    sns.barplot(data=df_agg, x="control_mode", y="perc_change_emission")
    plt.xticks(rotation=45)
    plt.xlabel("Control Mode")
    plt.ylabel("Percentage Change in CO2 Emission (%)")
    plt.title("Percentage Change in Average CO2 Emission Relative to Baseline")
    plt.tight_layout()
    plt.savefig(f"{ROOT}perc_change_emission.png")
    plt.show()


# Run the required pre-prepared simulations
for month in range(3, 11, 2):
    if month < 10:
        month = f"0{month}"
    DAY = f"2024-{month}-01"
    DAY_PLUS1 = f"2024-{month}-02"
    run_simu()

    DAY = f"2024-{month}-15"
    DAY_PLUS1 = f"2024-{month}-16"
    run_simu()

